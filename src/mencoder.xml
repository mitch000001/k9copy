<OPTIONS>
    <AUDIO>
        <lavc options="lavcopts">
            <opt type="string" name="acodec" default="mp3">
                <value name="mp3"/>
                <value name="mp2"/>
                <value name="ac3"/>
                <value name="adpcm_ima_wav"/>
                <value name="sonic"/>
            </opt>
            <opt type="int" name="abitrate" min="1" max="1000" default="$AUDBR" special="$AUDBR"/>
        </lavc>
        <toolame options="toolameopts">
            <opt type="int" name="br" min="0" max="384" default="$AUDBR" special="$AUDBR"/>
            <opt type="int" name="vbr" min="-50" max="50" default="0" />
            <opt type="int" name="maxvbr" min="32" max="384" default="384"/>
            <opt type="string" name="mode" default="stereo">
                <value name="stereo"/>
                <value name="jstereo"/>
                <value name="mono"/>
                <value name="dual"/>
            </opt>
            <opt type="int" name="psy" min="1" max="4"/>
            <opt type="int" name="errprot" min="0" max="1" default="0" />
        </toolame>
        <faac options="faacopts">
            <opt type="int" name="br" min="1" max="1000" default="$AUDBR" special="$AUDBR" description="average bitrate in kbps (mutually exclusive with quality)"/>
            <opt type="int" name="quality" min="1" max="1000" default="500" description="quality mode, the higher the better (mutually exclusive with br)"/>
            <opt type="int" name="object" min="1" max="4" default="1" description="object type complexity&lt;br&gt;1:MAIN&lt;br&gt;2:LOW&lt;br&gt;3:SSR&lt;br&gt;4:LTP (extremely slow)"/>
            <opt type="string" name="mpeg"  default="4">
                <value name="2"/>
                <value name="4"/>
            </opt>
            <opt type="bool" name="tns" default="true" description="Enables temporal noise shaping."/>
            <opt type="int" name="cutoff" min="0" max="24000" default="22050" description="cutoff frequency (default: sampling_rate/2)"/>
            <opt type="bool" name="raw" default="false" description="Stores the bitstream as raw payload with extradata in the container header (default: 0, corresponds to ADTS).&lt;br&gt;Do not set this flag if not explicitly required or you will not be able to remux the audio stream later on."/>
        </faac>
    </AUDIO>
    
    <VIDEO>
        <xvid options="xvidencopts">
            <opt type="int" name="pass" min="1" max="2" default="$PASS" special="$PASS" description="Specify the pass in two pass mode."/>
            <opt type="bool" name="turbo" default="false" description="Dramatically speeds up pass one using faster algorithms and disabling CPU-intensive options.&lt;br&gt; This will probably reduce global PSNR a little bit and change individual frame type and PSNR a little bit more." />
            <opt type="int" name="bitrate" default="$VIDBR" min="-10000" max="16000" default="$VIDBR" description="Sets the bitrate to be used in kbits/second. &lt;br&gt; If value is negative, Xvid will use its absolute value as the target size (in kBytes) of the video and compute the associated bitrate automagically (default: 687 kbits/s)." />
            <opt type="int" name="fixed_quant" default="1" min="1" max="31" description="Switch to fixed quantizer mode and specify the quantizer to be used."/>
            <opt type="int" name="me_quality" default="6" min="0" max="6" description="This option controls the motion estimation subsystem. The higher the value, the more precise the estimation should be (default: 6)&lt;br&gt; The more precise the motion estimation is, the more bits can be saved. Precision is gained at the expense of CPU time so decrease this setting if you need realtime encoding."/>
            <opt type="bool" name="qpel" default="false" description="MPEG-4 uses a half pixel precision for its motion search by default. The standard proposes a mode where encoders are allowed to use quarter pixel precision.&lt;br&gt;This option usually results in a sharper image. Unfortunately it has a great impact on bitrate and sometimes the higher bitrate use will prevent it from giving a better image quality at a fixed bitrate. It is better to test with and without this option and see whether it is worth activating."/>
            <opt type="bool" name="noqpel" default="false" description="MPEG-4 uses a half pixel precision for its motion search by default. The standard proposes a mode where encoders are allowed to use quarter pixel precision.&lt;br&gt;This option usually results in a sharper image. Unfortunately it has a great impact on bitrate and sometimes the higher bitrate use will prevent it from giving a better image quality at a fixed bitrate. It is better to test with and without this option and see whether it is worth activating."/>
            <opt type="bool" name="gmc" default="false" description="Enable Global Motion Compensation, which makes Xvid generate special frames (GMC-frames) which are well suited for Pan/Zoom/ Rotating images.&lt;br&gt; Whether or not the use of this option will save bits is highly dependent on the source material."/>
            <opt type="bool" name="nogmc" default="false" description="Enable Global Motion Compensation, which makes Xvid generate special frames (GMC-frames) which are well suited for Pan/Zoom/ Rotating images.&lt;br&gt; Whether or not the use of this option will save bits is highly dependent on the source material."/>
            <opt type="bool" name="trellis" default="false" description="Trellis Quantization is a kind of adaptive quantization method that saves bits by modifying quantized coefficients to make them more compressible by the entropy encoder.&lt;br&gt;Its impact on quality is good, and if VHQ uses too much CPU for you, this setting can be a good alternative to save a few bits (and gain quality at fixed bitrate) at a lesser cost than with VHQ (default: on)."/>
            <opt type="bool" name="notrellis" default="false" description="Trellis Quantization is a kind of adaptive quantization method that saves bits by modifying quantized coefficients to make them more compressible by the entropy encoder.&lt;br&gt;Its impact on quality is good, and if VHQ uses too much CPU for you, this setting can be a good alternative to save a few bits (and gain quality at fixed bitrate) at a lesser cost than with VHQ (default: on)."/>
            <opt type="bool" name="cartoon" default="false" description="Activate this if your encoded sequence is an anime/cartoon.&lt;br&gt;It modifies some Xvid internal thresholds so Xvid takes better decisions on frame types and motion vectors for flat looking cartoons."/>
            <opt type="bool" name="nocartoon" default="false" description="Activate this if your encoded sequence is an anime/cartoon.&lt;br&gt;It modifies some Xvid internal thresholds so Xvid takes better decisions on frame types and motion vectors for flat looking cartoons."/>
            <opt type="bool" name="chroma_me" default="false" description="The usual motion estimation algorithm uses only the luminance information to find the best motion vector.&lt;br&gt; However for some video material, using the chroma planes can help find better vectors. This setting toggles the use of chroma planes for motion estimation (default: on)."/>
            <opt type="bool" name="nochroma_me" default="false" description="The usual motion estimation algorithm uses only the luminance information to find the best motion vector.&lt;br&gt; However for some video material, using the chroma planes can help find better vectors. This setting toggles the use of chroma planes for motion estimation (default: on)."/>
            <opt type="bool" name="chroma_opt" default="false" description="Enable a chroma optimizer prefilter. It will do some extra magic on color information to minimize the stepped-stairs effect on edges.&lt;br&gt; It will improve quality at the cost of encoding speed. It reduces PSNR by nature, as the mathematical deviation to the original picture will get bigger, but the subjective image quality will raise. Since it works with color information, you might want to turn it off when encoding in grayscale."/>
            <opt type="bool" name="nochroma_opt" default="false" description="Enable a chroma optimizer prefilter. It will do some extra magic on color information to minimize the stepped-stairs effect on edges.&lt;br&gt; It will improve quality at the cost of encoding speed. It reduces PSNR by nature, as the mathematical deviation to the original picture will get bigger, but the subjective image quality will raise. Since it works with color information, you might want to turn it off when encoding in grayscale."/>
            <opt type="bool" name="hq_ac" default="false" description="Activates high-quality prediction of AC coefficients&lt;br&gt;for intra frames from neighbor blocks (default: on)."/>
            <opt type="bool" name="nohq_ac" default="false" description="Activates high-quality prediction of AC coefficients&lt;br&gt;for intra frames from neighbor blocks (default: on)."/>
            <opt type="int" name="vhq" default="1" min="0" max="4" description="The motion search algorithm is based on a search in the usual color domain and tries to find a motion vector that minimizes the difference between the reference frame and the encoded frame.&lt;br&gt; With this setting activated, Xvid will also use the frequency domain (DCT) to search for a motion vector that minimizes not only the spatial difference but also the encoding length of the block. Fastest to slowest:&lt;br&gt;0 : off&lt;br&gt;1 : mode decision (inter/intra MB) (default)&lt;br&gt;2 : limited search&lt;br&gt;3 : medium search&lt;br&gt;4 : wide search"/>
            <opt type="bool" name="lumi_mask" default="false" description="Adaptive quantization allows the macroblock quantizers to vary inside each frame.&lt;br&gt; This is a ’psychosensory’ setting that is supposed to make use of the fact that the human eye tends to notice fewer details in very bright and very dark parts of the picture. It compresses those areas more strongly than medium ones, which will save bits that can be spent again on other frames, raising overall subjective quality and possibly reducing PSNR."/>
            <opt type="bool" name="nolumi_mask" default="false" description="Adaptive quantization allows the macroblock quantizers to vary inside each frame.&lt;br&gt; This is a ’psychosensory’ setting that is supposed to make use of the fact that the human eye tends to notice fewer details in very bright and very dark parts of the picture. It compresses those areas more strongly than medium ones, which will save bits that can be spent again on other frames, raising overall subjective quality and possibly reducing PSNR."/>
            <opt type="bool" name="grayscale" default="false" description="Make Xvid discard chroma planes so the encoded video is grayscale only.&lt;br&gt;Note that this does not speed up encoding, it just prevents chroma data from being written in the last stage of encoding."/>
            <opt type="bool" name="nograyscale" default="false" description="Make Xvid discard chroma planes so the encoded video is grayscale only.&lt;br&gt;Note that this does not speed up encoding, it just prevents chroma data from being written in the last stage of encoding."/>
            <opt type="bool" name="interlacing" default="false" description="Encode the fields of interlaced video material. Turn this option on for interlaced content.&lt;br&gt;NOTE: Should you rescale the video, you would need an interlace-aware resizer, which you can activate with −vf scale=width:height:1."/>
            <opt type="bool" name="nointerlacing" default="false" description="Encode the fields of interlaced video material. Turn this option on for interlaced content.&lt;br&gt;NOTE: Should you rescale the video, you would need an interlace-aware resizer, which you can activate with −vf scale=width:height:1."/>
            <opt type="int" name="min_iquant" default="2" min="0" max="31" description="minimum I-frame quantizer (default: 2)"/>
            <opt type="int" name="max_iquant" default="31" min="0" max="31" description="maximum I-frame quantizer (default: 31)"/>
            <opt type="int" name="min_bquant" default="2" min="0" max="31" description="minimum B-frame quantizer (default: 2)"/>
            <opt type="int" name="max_bquant" default="31" min="0" max="31" description="maximum B-frame quantizer (default: 31)"/>
            <opt type="int" name="min_pquant" default="2" min="0" max="31" description="minimum P-frame quantizer (default: 2)"/>
            <opt type="int" name="max_pquant" default="31" min="0" max="31" description="maximum P-frame quantizer (default: 31)"/>
            <opt type="int" name="min_key_interval" default="0" min="0" max="400" description=" (two pass only)&lt;br&gt;minimum interval between keyframes (default: 0)"/>
            <opt type="int" name="max_key_interval" default="0" min="0" max="400" description="maximum interval between keyframes (default: 10*fps)"/>
            <opt type="string" name="quant_type" default="mpeg" description="Sets the type of quantizer to use.&lt;br&gt;For high bitrates, you will find that MPEG quantization preserves more detail. For low bitrates, the smoothing of H.263 will give you less block noise. When using custom matrices, MPEG quantization must be used.">
                <value name="h263"/>
                <value name="mpeg"/>
            </opt>
            <opt type="int" name="keyframe_boost" default="0" min="0" max="1000" description="Shift some bits from the pool for other frame types to intra frames, thus improving keyframe quality.&lt;br&gt;This amount is an extra percentage, so a value of 10 will give your keyframes 10% more bits than normal (default: 0).&lt;br&gt;(two pass mode only)"/>
            <opt type="int" name="kfthreshold" default="10" min="0" max="100" description="Works together with kfreduction. Determines the minimum distance below which you consider that two frames are considered consecutive and treated differently according to kfreduction (default: 10).&lt;br&gt;(two pass mode only)"/>
            <opt type="int" name="kfreduction" default="30" min="0" max="100" description="The above two settings can be used to adjust the size of keyframes that you consider too close to the first (in a row). kfthreshold sets the range in which keyframes are reduced, and kfreduction determines the bitrate reduction they get. The last I-frame will get treated normally (default: 30)&lt;br&gt;(two pass mode only)"/>
            <opt type="int" name="max_bframes" min="0" max="4" default="2" description="Maximum number of B-frames to put between I/P-frames (default: 2)."/> 
            <opt type="int" name="bquant_ratio" min="0" max="1000" default="150" description="quantizer ratio between B- and non-B-frames, 150=1.50 (default: 150)"/>
            <opt type="int" name="bquant_offset" min="-1000" max="1000" default="100" description="quantizer offset between B- and non-B-frames, 100=1.00 (default: 100)"/>
            <opt type="int" name="bf_threshold" min="-255" max="255" default="0" description="This setting allows you to specify what priority to place on the use of B-frames.&lt;br&gt;The higher the value, the higher the probability of B-frames being used (default: 0). Do not forget that B-frames usually have a higher quantizer, and therefore aggressive production of B-frames may cause worse visual quality."/>
            <opt type="bool" name="closed_gop" default="true" description="This option tells Xvid to close every GOP (Group Of Pictures bounded by two I-frames), which makes GOPs independent from each other.&lt;br&gt;This just implies that the last frame of the GOP is either a P-frame or a N-frame but not a B-frame. It is usually a good idea to turn this option on (default: on)"/>
            <opt type="bool" name="noclosed_gop" default="true" description="This option tells Xvid to close every GOP (Group Of Pictures bounded by two I-frames), which makes GOPs independent from each other.&lt;br&gt;This just implies that the last frame of the GOP is either a P-frame or a N-frame but not a B-frame. It is usually a good idea to turn this option on (default: on)"/>
            <opt type="bool" name="packed" default="true" description="This option is meant to solve frame-order issues when encoding to container formats like AVI that cannot cope with out-of-order frames.&lt;br&gt;In practice, most decoders (both software and hardware) are able to deal with frame-order themselves, and may get confused when this option is turned on, so you can safely leave if off, unless you really know what you are doing.&lt;br&gt;WARNING: This will generate an illegal bitstream, and will not be decodable by ISO-MPEG-4 decoders except DivX/libavcodec/ Xvid.&lt;br&gt;WARNING: This will also store a fake DivX version in the file so the bug autodetection of some decoders might be confused."/>
            <opt type="bool" name="nopacked" default="true" description="This option is meant to solve frame-order issues when encoding to container formats like AVI that cannot cope with out-of-order frames.&lt;br&gt;In practice, most decoders (both software and hardware) are able to deal with frame-order themselves, and may get confused when this option is turned on, so you can safely leave if off, unless you really know what you are doing.&lt;br&gt;WARNING: This will generate an illegal bitstream, and will not be decodable by ISO-MPEG-4 decoders except DivX/libavcodec/ Xvid.&lt;br&gt;WARNING: This will also store a fake DivX version in the file so the bug autodetection of some decoders might be confused."/>
            <opt type="int" name="frame_drop_ratio" default="0" min="0" max="100" description="This setting allows the creation of variable framerate video streams. The value of the setting specifies a threshold under which, if the difference of the following frame to the previous frame is below or equal to this threshold, a frame gets not coded (a so called n-vop is placed in the stream). On playback, when reaching an n-vop the previous frame will be displayed.&lt;br&gt;WARNING: Playing with this setting may result in a jerky video, so use it at your own risks!"/>
            <opt type="int" name="rc_reacting_delay_factor" min="0" max="1000" default="0" description="This parameter controls the number of frames the CBR rate controller will wait before reacting to bitrate changes&lt;br&gt;and compensating for them to obtain a constant bitrate over an averaging range of frames."/>
            <opt type="int" name="rc_averaging_period" min="0" max="1000" default="0" description="Real CBR is hard to achieve. Depending on the video material, bitrate can be variable, and hard to predict.&lt;br&gt;Therefore Xvid uses an averaging period for which it guarantees a given amount of bits (minus a small variation). This settings expresses the 'number of frames' for which Xvid averages bitrate and tries to achieve CBR."/>
            <opt type="int" name="rc_buffer" min="0" max="10000" default="0" description="size of the rate control buffer"/>
            <opt type="int" name="curve_compression_high" min="0" max="100" default="0" description="This setting allows Xvid to take a certain percentage of bits away from high bitrate scenes and give them back to the bit reservoir.&lt;br&gt;You could also use this if you have a clip with so many bits allocated to high-bitrate scenes that the low(er)-bitrate scenes start to look bad (default: 0)"/>
            <opt type="int" name="curve_compression_low" min="0" max="100" default="0" description="This setting allows Xvid to give a certain percentage of extra bits to the low bitrate scenes, taking a few bits from the entire clip.&lt;br&gt;This might come in handy if you have a few low-bitrate scenes that are still blocky (default: 0)."/>
            <opt type="int" name="overflow_control_strength" min="0" max="100" default="5" description="During pass one of two pass encoding, a scaled bitrate curve is computed. The difference between that expected curve and the result obtained during encoding is called overflow. Obviously, the two pass rate controller tries to compensate for that overflow, distributing it over the next frames. This setting controls how much of the overflow is distributed every time there is a new frame. Low values allow lazy overflow control, big rate bursts are compensated for more slowly (could lead to lack of precision for small clips). Higher values will make changes in bit redistribution more abrupt, possibly too abrupt if you set it too high, creating artifacts (default: 5).&lt;br&gt;NOTE: This setting impacts quality a lot, play with it carefully!"/>
            <opt type="int" name="max_overflow_improvement" min="0" max="100" default="5" description="During the frame bit allocation, overflow control may increase the frame size.&lt;br&gt;This parameter specifies the maximum percentage by which the overflow control is allowed to increase the frame size, compared to the ideal curve allocation (default: 5)."/>
            <opt type="int" name="max_overflow_degradation" min="0" max="100" default="5" description="During the frame bit allocation, overflow control may decrease the frame size.&lt;br&gt;This parameter specifies the maximum percentage by which the overflow control is allowed to decrease the frame size, compared to the ideal curve allocation (default: 5)."/>
            <opt type="int" name="container_frame_overhead" min="0" max="1000" default="0" description="Specifies a frame average overhead per frame, in bytes. Most of the time users express their target bitrate for video w/o taking care of the video container overhead.&lt;br&gt;This small but (mostly) constant overhead can cause the target file size to be exceeded. Xvid allows users to set the amount of overhead per frame the container generates (give only an average per frame). 0 has a special meaning, it lets Xvid use its own default values (default: 24 − AVI average overhead)."/>
            <opt type="string" name="profile" default="unrestricted" description="Restricts options and VBV (peak bitrate over a short period) according to the Simple, Advanced Simple and DivX profiles. The resulting videos should be playable on standalone players adhering to these profile specifications.&lt;br&gt;- unrestricted : no restrictions (default)&lt;br&gt;- sp0 : simple profile at level 0&lt;br&gt;- sp1 : simple profile at level 1&lt;br&gt;- sp2 : simple profile at level 2&lt;br&gt;- sp3 : simple profile at level 3&lt;br&gt;- asp0 : advanced simple profile at level 0&lt;br&gt;- asp1 : advanced simple profile at level 1&lt;br&gt;- asp2 : advanced simple profile at level 2&lt;br&gt;- asp3 : advanced simple profile at level 3&lt;br&gt;- asp4 : advanced simple profile at level 4&lt;br&gt;- asp5 : advanced simple profile at level 5&lt;br&gt;- dxnhandheld : DXN handheld profile&lt;br&gt;- dxnportntsc : DXN portable NTSC profile&lt;br&gt;- dxnportpal : DXN portable PAL profile&lt;br&gt;- dxnhtntsc : DXN home theater NTSC profile&lt;br&gt;- dxnhtpal : DXN home theater PAL profile&lt;br&gt;- dxnhdtv : DXN HDTV profile&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: These profiles should be used in conjunction with an appropriate −ffourcc. Generally DX50 is applicable, as some players do not recognize Xvid but most recognize DivX.">
                <value name="unrestricted"/>
                <value name="sp0"/>
                <value name="sp3"/>
                <value name="asp0"/>
                <value name="asp1"/>
                <value name="asp2"/>
                <value name="asp3"/>
                <value name="asp4"/>
                <value name="asp5"/>
                <value name="dxnhandheld"/>
                <value name="dxnportntsc"/>
                <value name="dxnhtntsc"/>
                <value name="dxnhtpal"/>
                <value name="dxnhdtv"/>
            </opt>
            <opt type="string" name="par" default="vga11" description="Specifies the Pixel Aspect Ratio mode (not to be confused with DAR, the Display Aspect Ratio). PAR is the ratio of the width and height of a single pixel. So both are related like this: DAR = PAR * (width/height).&lt;br&gt;MPEG-4 defines 5 pixel aspect ratios and one extended one, giving the opportunity to specify a specific pixel aspect ratio. 5 standard modes can be specified:&lt;br&gt;- vga11 : It is the usual PAR for PC content. Pixels are a square unit.&lt;br&gt;- pal43 : PAL standard 4:3 PAR. Pixels are rectangles.&lt;br&gt;- pal169 : same as above&lt;br&gt;- ntsc43 : same as above&lt;br&gt;- ntsc169 : same as above (Do not forget to give the exact ratio.)&lt;br&gt;- ext :Allows you to specify your own pixel aspect ratio with par_width and par_height.&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: In general, setting aspect and autoaspect options is enough.">
                <value name="vga11"/>
                <value name="pal43"/>
                <value name="pal169"/>
                <value name="ntsc43"/>
                <value name="ntsc169"/>
                <value name="ext"/>
            </opt>
            <opt type="int" name="par_width" min="1" max="255" default="1" description="Specifies the width of the custom pixel aspect ratio."/>
            <opt type="int" name="par_height" min="1" max="255" default="1" description="Specifies the height of the custom pixel aspect ratio."/>
            <opt type="string" name="aspect" default="16/9" description="Store movie aspect internally, just like MPEG files. Much nicer solution than rescaling, because quality is not decreased.&lt;br&gt;MPlayer and a few others players will play these files correctly, others will display them with the wrong aspect. The aspect parameter can be given as a ratio or a floating point number." />
            <opt type="bool" name="autoaspect" default="false" description="Same as the aspect option, but automatically computes aspect, taking into account all the adjustments (crop/expand/scale/ etc.) made in the filter chain."/>
            <opt type="bool" name="noautoaspect" default="false" description="Same as the aspect option, but automatically computes aspect, taking into account all the adjustments (crop/expand/scale/ etc.) made in the filter chain."/>
            <opt type="bool" name="psnr" default="false" description="Print the PSNR (peak signal to noise ratio) for the whole video after encoding and store the per frame PSNR in a file with a name like ’psnr_hhmmss.log’ in the current directory.&lt;br&gt;Returned values are in dB (decibel), the higher the better."/>
            <opt type="bool" name="debug" default="false" description="Save per-frame statistics in ./xvid.dbg. (This is not the two pass control file.)" />
            <opt type="int" name="threads" default="0" min="0" max="50" description="Create n threads to run the motion estimation (default: 0).&lt;br&gt;The maximum number of threads that can be used is the picture height divided by 16."/>
        </xvid>
        <x264 options="x264encopts">
            <opt type="int" name="bitrate" min="0" max="16000" special="$VIDBR" default="$VIDBR" description="Sets the average bitrate to be used in kbits/second (default: off).&lt;br&gt;Since local bitrate may vary, this average may be inaccurate for very short videos (see ratetol). Constant bitrate can be achieved by combining this with vbv_maxrate, at significant reduction in quality."/>
            <opt type="int" name="qp" min="0" max="51" default="26" description="This selects the quantizer to use for P-frames. I- and B-frames are offset from this value by ip_factor and pb_factor, respectively. 20−40 is a useful range (default: 26).&lt;br&gt;Lower values result in better fidelity, but higher bitrates. 0 is lossless. Note that quantization in H.264 works differently from MPEG-1/2/4: H.264’s quantization parameter (QP) is on a logarithmic scale. The mapping is approximately H264QP = 12 + 6*log2(MPEGQP). For example, MPEG at QP=2 is equivalent to H.264 at QP=18"/>
            <opt type="double" name="crf" min="1.0" max="50.0" default="0" description="Enables constant quality mode, and selects the quality. The scale is similar to QP. Like the bitrate-based modes, this allows each frame to use a different QP based on the frame’s complexity."/>
            <opt type="int" name="pass" min="1" max="3" special="$PASS" default="$PASS" description="Enable 2 or 3-pass mode. It is recommended to always encode in 2 or 3-pass mode as it leads to a better bit distribution and improves overall quality.&lt;br&gt;-  1 : first pass&lt;br&gt;-  2 : second pass (of two pass encoding)&lt;br&gt;-  3 : Nth pass (second and third passes of three pass encoding)&lt;br&gt;&lt;br&gt;Here is how it works, and how to use it:&lt;br&gt;The first pass (pass=1) collects statistics on the video and writes them to a file. You might want to deactivate some CPU-hungry options, apart from the ones that are on by default.&lt;br&gt;In two pass mode, the second pass (pass=2) reads the statistics file and bases ratecontrol decisions on it.&lt;br&gt;In three pass mode, the second pass (pass=3, that is not a typo) does both: It first reads the statistics, then overwrites them. You can use all encoding options, except very CPU-hungry options.&lt;br&gt;The third pass (pass=3) is the same as the second pass, except that it has the second pass’ statistics to work from. You can use all encoding options, including CPU-hungry ones.&lt;br&gt;The first pass may use either average bitrate or constant quantizer. ABR is recommended, since it does not require guessing a quantizer. Subsequent passes are ABR, and must specify bitrate."/>
            <opt type="int" name="turbo" min="0" max="2" default="0" description="Fast first pass mode. During the first pass of a two or more pass encode it is possible to gain speed by disabling some options with negligible or even no impact on the final pass output quality.&lt;br&gt;-  0 : disabled  (default)&lt;br&gt;-  1 : Reduce subq, frameref and disable some inter-macroblock partition analysis modes.&lt;br&gt;-  2 : Reduce subq and frameref to 1, use a diamond ME search and disable all partition analysis modes.&lt;br&gt;&lt;br&gt;Level 1 can increase first pass speed up to 2x with no change in the global PSNR of the final pass compared to a full quality first pass.&lt;br&gt;Level 2 can increase first pass speed up to 4x with about +/- 0.05dB change in the global PSNR of the final pass compared to a full quality first pass."/>
            <opt type="int" name="keyint" min="0" max="1000" default="250" description="Sets maximum interval between IDR-frames (default: 250). Larger values save bits, thus improve quality, at the cost of seeking precision.&lt;br&gt;Unlike MPEG-1/2/4, H.264 does not suffer from DCT drift with large values of keyint."/>
            <opt type="int" name="keyint_min" min="0" max="1000" default="25" description="Sets minimum interval between IDR-frames (default: 25).&lt;br&gt;If scenecuts appear within this interval, they are still encoded as I-frames, but do not start a new GOP. In H.264, I-frames do not necessarily bound a closed GOP because it is allowable for a P-frame to be predicted from more frames than just the one frame before it (also see frameref). Therefore, I-frames are not necessarily seekable. IDR-frames restrict subsequent P-frames from referring to any frame prior to the IDR-frame."/>
            <opt type="int" name="scenecut" min="1" max="100" default="40" description="Controls how aggressively to insert extra I-frames (default: 40).&lt;br&gt;With small values of scenecut, the codec often has to force an I-frame when it would exceed keyint. Good values of scenecut may find a better location for the I-frame. Large values use more I-frames than necessary, thus wasting bits. -1 disables scene-cut detection, so I-frames are inserted only once every other keyint frames, even if a scene-cut occurs earlier. This is not recommended and wastes bitrate as scenecuts encoded as P-frames are just as big as I-frames, but do not reset the 'keyint counter'."/>
            <opt type="int" name="frameref" min="1" max="16" default="1" description="Number of previous frames used as predictors in B- and P-frames (default: 1).&lt;br&gt;This is effective in anime, but in live-action material the improvements usually drop off very rapidly above 6 or so reference frames. This has no effect on decoding speed, but does increase the memory needed for decoding. Some decoders can only handle a maximum of 15 reference frames."/>
            <opt type="int" name="bframes" min="0" max="16" default="0" description="maximum number of consecutive B-frames between I- and P-frames (default: 0)"/>
            <opt type="bool" name="b_adapt" default="true" description="Automatically decides when to use B-frames and how many, up to the maximum specified above (default: on).&lt;br&gt;If this option is disabled, then the maximum number of B-frames is used."/>
            <opt type="bool" name="nob_adapt" default="true" description="Automatically decides when to use B-frames and how many, up to the maximum specified above (default: on).&lt;br&gt;If this option is disabled, then the maximum number of B-frames is used."/>
            <opt type="int" name="b_bias" min="-100" max="100" default="0" description="Controls the decision performed by b_adapt. A higher b_bias produces more B-frames (default: 0)."/>
            <opt type="bool" name="b_pyramid" default="false" description="Allows B-frames to be used as references for predicting other frames.&lt;br&gt;For example, consider 3 consecutive B-frames: I0 B1 B2 B3 P4. Without this option, B-frames follow the same pattern as MPEG-[124]. So they are coded in the order I0 P4 B1 B2 B3, and all the B-frames are predicted from I0 and P4. With this option, they are coded as I0 P4 B2 B1 B3. B2 is the same as above, but B1 is predicted from I0 and B2, and B3 is predicted from B2 and P4. This usually results in slightly improved compression, at almost no speed cost. However, this is an experimental option: it is not fully tuned and may not always help. Requires bframes >= 2. Disadvantage: increases decoding delay to 2 frames."/>
            <opt type="bool" name="nob_pyramid" default="false" description="Allows B-frames to be used as references for predicting other frames.&lt;br&gt;For example, consider 3 consecutive B-frames: I0 B1 B2 B3 P4. Without this option, B-frames follow the same pattern as MPEG-[124]. So they are coded in the order I0 P4 B1 B2 B3, and all the B-frames are predicted from I0 and P4. With this option, they are coded as I0 P4 B2 B1 B3. B2 is the same as above, but B1 is predicted from I0 and B2, and B3 is predicted from B2 and P4. This usually results in slightly improved compression, at almost no speed cost. However, this is an experimental option: it is not fully tuned and may not always help. Requires bframes >= 2. Disadvantage: increases decoding delay to 2 frames."/>
            <opt type="bool" name="deblock" default="true" description="Use deblocking filter (default: on). As it takes very little time compared to its quality gain,&lt;br&gt;it is not recommended to disable it."/>
            <opt type="bool" name="nodeblock" default="false" description="Use deblocking filter (default: on). As it takes very little time compared to its quality gain,&lt;br&gt;it is not recommended to disable it."/>
            <opt name="deblock" description="The first parameter is AlphaC0 (default: 0). This adjusts thresholds for the H.264 in-loop deblocking filter. First, this parameter adjusts the maximum amount of change that the filter is allowed to cause on any one pixel. Secondly, this parameter affects the threshold for difference across the edge being filtered. A positive value reduces blocking artifacts more, but will also smear details. The second parameter is Beta (default: 0).&lt;br&gt; This affects the detail threshold. Very detailed blocks are not filtered, since the smoothing caused by the filter would be more noticeable than the original blocking.The default behavior of the filter almost always achieves optimal quality, so it is best to either leave it alone, or make only small adjustments. However, if your source material already has some blocking or noise which you would like to remove, it may be a good idea to turn it up a little bit.">
                 <subopt type="int" min="-6" max="6" default="0"/>
                 <subopt type="int" min="-6" max="6" default="0"/>
            </opt>
            <opt type="bool" name="cabac" default="true" description="Use CABAC (Context-Adaptive Binary Arithmetic Coding) (default: on). Slightly slows down encoding and decoding, but should save 10-15% bitrate.&lt;br&gt;Unless you are looking for decoding speed, you should not disable it."/>
            <opt type="bool" name="nocabac" default="false" description="Use CABAC (Context-Adaptive Binary Arithmetic Coding) (default: on). Slightly slows down encoding and decoding, but should save 10-15% bitrate.&lt;br&gt;Unless you are looking for decoding speed, you should not disable it."/>
            <opt type="int" name="qp_min" min="1" max="51" default="10" description="(ABR or two pass)&lt;br&gt;Minimum quantizer, 10−30 seems to be a useful range (default: 10)."/>
            <opt type="int" name="qp_max" min="1" max="51" default="51" description="(ABR or two pass)&lt;br&gt;maximum quantizer (default: 51)"/>
            <opt type="int" name="qp_step" min="1" max="50" default="4" description="(ABR or two pass)&lt;br&gt;maximum value by which the quantizer may be incremented/decremented between frames (default: 4)"/>
            <opt type="float" name="ratetol" min="0.1" max="100.0" default="1.0" description="(ABR or two pass)&lt;br&gt;allowed variance in average bitrate (no particular units) (default: 1.0)	"/>
            <opt type="int" name="vbv_maxrate" min="0" max="16000" default="0" description="(ABR or two pass)&lt;br&gt;maximum local bitrate, in kbits/second (default: disabled)"/>
            <opt type="int" name="vbv_bufsize" min="0" max="10000" default="0" description="(ABR or two pass)&lt;br&gt;averaging period for vbv_maxrate, in kbits (default: none, must be specified if vbv_maxrate is enabled)"/>
            <opt type="float" name="vbv_init" min="0.0" max="1.0" default="0.9" description="(ABR or two pass)&lt;br&gt;initial buffer occupancy, as a fraction of vbv_bufsize (default: 0.9)"/>
            <opt type="float" name="ip_factor" min="0.0" max="10.0" default="1.4" description="quantizer factor between I- and P-frames (default: 1.4)"/>
            <opt type="float" name="pb_factor" min="0.0" max="10.0" default="1.3" description="quantizer factor between P- and B-frames (default: 1.3)"/>
            <opt type="float" name="qcomp" min="0.0" max="1.0" default="0.6" description="(ABR or two pass)&lt;br&gt;quantizer compression (default: 0.6). A lower value makes the bitrate more constant, while a higher value makes the quantization parameter more constant."/>
            <opt type="int" name="cplx_blur" min="0" max="999" default="20" description="(two pass only)&lt;br&gt;Temporal blur of the estimated frame complexity, before curve compression (default: 20).&lt;br&gt; Lower values allow the quantizer value to jump around more, higher values force it to vary more smoothly. cplx_blur ensures that each I-frame has quality comparable to the following P-frames, and ensures that alternating high and low complexity frames (e.g. low fps animation) do not waste bits on fluctuating quantizer."/>
            <opt type="float" name="qblur" min="0" max="99" default="0.5" description="(two pass only)&lt;br&gt;Temporal blur of the quantization parameter, after curve compression (default: 0.5). Lower values allow the quantizer value to jump around more, higher values force it to vary more smoothly.&lt;br&gt;"/>
            <opt type="string" name="direct_pred" default="spatial" description="Determines the type of motion prediction used for direct macroblocks in B-frames.&lt;br&gt;-  none : Direct macroblocks are not used&lt;br&gt;-  spatial : Motion vectors are extrapolated from neighboring blocks. (default)&lt;br&gt;-  temporal : Motion vectors are interpolated from the following P-frame.&lt;br&gt;-  auto : The codec selects between spatial and temporal for each frame.&lt;br&gt;Spatial and temporal are approximately the same speed and PSNR, the choice between them depends on the video content. Auto is slightly better, but slower. Auto is most effective when combined with multipass. direct_pred=none is both slower and lower quality.">
                <value name="none"/>
                <value name="spatial"/>
                <value name="temporal"/>
                <value name="auto"/>
            </opt>
            <opt type="bool" name="weight_b" default="false" description="Use weighted prediction in B-frames. Without this option, bidirectionally predicted macroblocks give equal weight to each reference frame.&lt;br&gt;With this option, the weights are determined by the temporal position of the B-frame relative to the references. Requires bframes > 1."/>
            <opt type="bool" name="noweight_b" default="false" description="Use weighted prediction in B-frames. Without this option, bidirectionally predicted macroblocks give equal weight to each reference frame.&lt;br&gt;With this option, the weights are determined by the temporal position of the B-frame relative to the references. Requires bframes > 1."/>
            <opt name="partitions" description="Enable some optional macroblock types (default: p8x8,b8x8,i8x8,i4x4)&lt;br&gt;-  p8x8 : Enable types p16x8, p8x16, p8x8&lt;br&gt;-  p4x4 : Enable types p8x4, p4x8, p4x4. p4x4 is recommended only with subq >= 5, and only at low resolutions.&lt;br&gt;-  b8x8 : Enable types b16x8, b8x16, b8x8.&lt;br&gt;-  i8x8 : Enable type i8x8. i8x8 has no effect unless 8x8dct is enabled.&lt;br&gt;-  i4x4 : Enable type i4x4.&lt;br&gt;-  all :Enable all of the above types.&lt;br&gt;-  none : Disable all of the above types.&lt;br&gt;Regardless of this option, macroblock types p16x16, b16x16, and i16x16 are always enabled.&lt;br&gt;The idea is to find the type and size that best describe a certain area of the picture. For example, a global pan is better represented by 16x16 blocks, while small moving objects are better represented by smaller blocks.">
                    <subopt type="string" default="p8x8">
                        <value name="all"/>
                        <value name="none"/>
                        <value name=""/>
                        <value name="p8x8"/>
                    </subopt>
                    <subopt type="string" default="">
                        <value name=""/>
                        <value name="p4x4"/>
                    </subopt>
                    <subopt type="string" default="b8x8">
                        <value name=""/>
                        <value name="b8x8"/>
                    </subopt>
                    <subopt type="string" default="i4x4">
                        <value name=""/>
                        <value name="i4x4"/>
                    </subopt>
            </opt>
            <opt type="bool" name="8x8dct" default="false" description="Adaptive spatial transform size: allows macroblocks to choose between 4x4 and 8x8 DCT.&lt;br&gt; Also allows the i8x8 macroblock type. Without this option, only 4x4 DCT is used."/>
            <opt type="bool" name="no8x8dct" default="false" description="Adaptive spatial transform size: allows macroblocks to choose between 4x4 and 8x8 DCT.&lt;br&gt; Also allows the i8x8 macroblock type. Without this option, only 4x4 DCT is used."/>
            <opt type="string" name="me" default="hex" description="Select fullpixel motion estimation algorithm.&lt;br&gt;-  dia : diamond search, radius 1 (fast)&lt;br&gt;-  hex : hexagon search, radius 2 (default)&lt;br&gt;-  umh : uneven multi-hexagon search (slow)&lt;br&gt;-  esa : exhaustive search (very slow, and no better than umh)">
                <value name="dia"/>
                <value name="hex"/>
                <value name="umh"/>
                <value name="esa"/>
            </opt>
            <opt type="int" name="me_range" min="4" max="64" default="16" description="radius of exhaustive or multi-hexagon motion search (default: 16)"/>
            <opt type="int" name="subq" min="1" max="7" default="5" description="Adjust subpel refinement quality. This parameter controls quality versus speed tradeoffs involved in the motion estimation decision process. subq=5 can compress up to 10% better than subq=1.&lt;br&gt;-  1 : Runs fullpixel precision motion estimation on all candidate macroblock types. Then selects the best type. Then refines the motion of that type to fast quarterpixel precision (fastest).&lt;br&gt;-  2 : Runs halfpixel precision motion estimation on all candidate macroblock types. Then selects the best type. Then refines the motion of that type to fast quarterpixel precision.&lt;br&gt;-  3 : As 2, but uses a slower quarterpixel refinement.&lt;br&gt;-  4 : Runs fast quarterpixel precision motion estimation on all candidate macroblock types. Then selects the best type. Then finishes the quarterpixel refinement for that type.&lt;br&gt;-  5 : Runs best quality quarterpixel precision motion estimation on all candidate macroblock types, before selecting the best type (default).&lt;br&gt;-  6 : Enables rate-distortion optimization of macroblock types in I- and P-frames.&lt;br&gt;-  7 : Enables rate-distortion optimization of motion vectors and intra modes. (best)&lt;br&gt;In the above, 'all candidates' does not exactly mean all enabled types: 4x4, 4x8, 8x4 are tried only if 8x8 is better than 16x16."/>
            <opt type="bool" name="chroma_me" default="true" description="Takes into account chroma information during subpixel motion search (default: enabled).&lt;br&gt; Requires subq>=5."/>
            <opt type="bool" name="nochroma_me" default="true" description="Takes into account chroma information during subpixel motion search (default: enabled).&lt;br&gt; Requires subq>=5."/>
            <opt type="bool" name="mixed_refs" default="false" description="Allows each 8x8 or 16x8 motion partition to independently select a reference frame.&lt;br&gt;Without this option, a whole macroblock must use the same reference. Requires frameref>1."/>
            <opt type="bool" name="nomixed_refs" default="false" description="Allows each 8x8 or 16x8 motion partition to independently select a reference frame.&lt;br&gt;Without this option, a whole macroblock must use the same reference. Requires frameref>1."/>
            <opt type="bool" name="brdo" default="false" description="Enables rate-distortion optimization of macroblock types in B-frames. Requires subq>=6."/>
            <opt type="bool" name="nobrdo" default="false" description="Enables rate-distortion optimization of macroblock types in B-frames. Requires subq>=6."/>
            <opt type="bool" name="bime" default="false" description="Refine the two motion vectors used in bidirectional macroblocks, rather than re-using vectors from the forward and backward searches. &lt;br&gt;This option has no effect without B-frames."/>
            <opt type="bool" name="nobime" default="false" description="Refine the two motion vectors used in bidirectional macroblocks, rather than re-using vectors from the forward and backward searches. &lt;br&gt;This option has no effect without B-frames."/>
            <opt type="int" name="trellis" min="0" max="2" default="0" description="rate-distortion optimal quantization&lt;br&gt;-  0 : disabled (default)&lt;br&gt;-  1 : enabled only for the final encode&lt;br&gt;-  2 : enabled   during all mode decisions (slow, requires subq>=6)"/>
            <opt type="int" name="deadzone_inter" min="0" max="32" default="21" description="Set the size of the inter luma quantization deadzone for non-trellis quantization (default: 21).&lt;br&gt;Lower values help to preserve fine details and film grain (typically useful for high bitrate/quality encode), while higher values help filter out these details to save bits that can be spent again on other macroblocks and frames (typically useful for bitrate-starved encodes). It is recommended that you start by tweaking deadzone_intra before changing this parameter."/>
            <opt type="int" name="deadzone_intra" min="0" max="32" default="11" description="Set the size of the intra luma quantization deadzone for non-trellis quantization (default: 11).&lt;br&gt;This option has the same effect as deadzone_inter except that it affects intra frames. It is recommended that you start by tweaking this parameter before changing deadzone_inter."/>
            <opt type="bool" name="fast_pskip" default="true" description="Performs early skip detection in P-frames (default: enabled).&lt;br&gt;This usually improves speed at no cost, but it can sometimes produce artifacts in areas with no details, like sky."/>
            <opt type="bool" name="nofast_pskip" default="true" description="Performs early skip detection in P-frames (default: enabled).&lt;br&gt;This usually improves speed at no cost, but it can sometimes produce artifacts in areas with no details, like sky."/>
            <opt type="bool" name="dct_decimate" default="true" description="Eliminate dct blocks in P-frames containing only a small single coefficient (default: enabled).&lt;br&gt; This will remove some details, so it will save bits that can be spent again on other frames, hopefully raising overall subjective quality. If you are compressing non-anime content with a high target bitrate, you may want to disable this to preserve as much detail as possible."/>
            <opt type="int" name="nr" min="0" max="0−100000" default="0" description="Noise reduction, 0 means disabled. 100−1000 is a useful range for typical content, but you may want to turn it up a bit more for very noisy content (default: 0).&lt;br&gt;Given its small impact on speed, you might want to prefer to use this over filtering noise away with video filters like denoise3d or hqdn3d."/>
            <opt type="int" name="chroma_qp_offset" min="-12" max="12" default="0" description="Use a different quantizer for chroma as compared to luma.&lt;br&gt;Useful values are in the range -2−2 (default: 0)."/> 
            <opt type="int" name="level_idc" min="10" max="51" default="51" description="Set the bitstream’s level as defined by annex A of the H.264 standard (default: 51 - Level 5.1).&lt;br&gt;This is used for telling the decoder what capabilities it needs to support. Use this parameter only if you know what it means, and you have a need to set it."/>
            <opt type="int" name="threads" min="0" max="16" default="1" special="auto" description="Spawn threads to encode in parallel on multiple CPUs (default: 1). This has a slight penalty to compression quality.&lt;br&gt;0 or ’auto’ tells x264 to detect how many CPUs you have and pick an appropriate number of threads."/>
            <opt type="bool" name="global_header" default="false" description="Causes SPS and PPS to appear only once, at the beginning of the bitstream (default: disabled).&lt;br&gt;Some players, such as the Sony PSP, require the use of this option. The default behavior causes SPS and PPS to repeat prior to each IDR frame."/>
            <opt type="bool" name="noglobal_header" default="false" description="Causes SPS and PPS to appear only once, at the beginning of the bitstream (default: disabled).&lt;br&gt;Some players, such as the Sony PSP, require the use of this option. The default behavior causes SPS and PPS to repeat prior to each IDR frame."/>
            <opt type="bool" name="interlaced" default="false" description="Treat the video content as interlaced."/>
            <opt type="bool" name="nointerlaced" default="false" description="Treat the video content as interlaced."/>
            <opt type="bool" name="ssim" default="false" description="Print the Structural Similarity Metric results.&lt;br&gt;This is an alternative to PSNR, and may be better correlated with the perceived quality of the compressed video."/>
            <opt type="bool" name="nossim" default="false" description="Print the Structural Similarity Metric results.&lt;br&gt;This is an alternative to PSNR, and may be better correlated with the perceived quality of the compressed video."/>
	    <opt type="bool" name="visualize" default="false" description="Enable x264 visualizations during encoding. If the x264 on your system supports it, a new window will be opened during the encoding process, in which x264 will attempt to present an overview of how each frame gets encoded.&lt;br&gt;Each block type on the visualized movie will be colored as follows:&lt;br&gt;- red/pink&lt;br&gt;- intra block&lt;br&gt;- blue&lt;br&gt;- inter block&lt;br&gt;- green&lt;br&gt;- skip block&lt;br&gt;- yellow&lt;br&gt;- B-block&lt;br&gt;&lt;br&gt;This feature can be considered experimental and subject to change. In particular, it depends on x264 being compiled with visualizations enabled. Note that as of writing this, x264 pauses after encoding and visualizing each frame, waiting for the user to press a key, at which point the next frame will be encoded."/>      
        </x264>
        <lavc options="lavcopts">
            <opt type="bool" name="bit_exact" default="false" description="Use only bit exact algorithms (except (I)DCT). Additionally bit_exact disables several optimizations and thus should only be used for regression tests, which need binary identical files even if the encoder version changes.&lt;br&gt;This also suppresses the user_data header in MPEG-4 streams. Do not use this option unless you know exactly what you are doing."/>
            <opt type="int"  name="threads" min="1" max="8" default="1" description="Maximum number of threads to use (default: 1). May have a slight negative effect on motion estimation."/>
            <opt type="string" name="vcodec" default="mpeg4" description="The video codec">
                <value name="mjpeg"/>                    
                <value name="ljpeg"/>
                <value name="h261"/>
                <value name="h263"/>
                <value name="h263p"/>
                <value name="mpeg4"/>
                <value name="msmpeg4"/>
                <value name="msmpeg4v2"/>
                <value name="wmv1"/>
                <value name="wmv2"/>
                <value name="rv10"/>
                <value name="mpeg1video"/>
                <value name="mpeg2video"/>
                <value name="huffyuv"/>
                <value name="ffvhuf"/>
                <value name="asv1"/>
                <value name="asv2"/>
                <value name="ffv1"/>
                <value name="flv"/>
                <value name="dvvideo"/>
                <value name="svq1"/>
                <value name="snow"/>
            </opt>
            <opt type="float" name="lmin" min="0.01" max="255.0" default="2.0" description="Minimum frame-level Lagrange multiplier for ratecontrol (default: 2.0). Lavc will rarely use quantizers below the value of lmin.&lt;br&gt;Lowering lmin will make lavc more likely to choose lower quantizers for some frames, but not lower than the value of vqmin. Likewise, raising lmin will make lavc less likely to choose low quantizers, even if vqmin would have allowed them. You probably want to set lmin approximately equal to vqmin. When adaptive quantization is in use, changing lmin/lmax may have less of an effect; see mblmin/mblmax."/>
            <opt type="float" name="lmax" min="0.01" max="255.0" default="31.0" description="maximum Lagrange multiplier for ratecontrol (default: 31.0)"/>
            <opt type="float" name="mblmin" min="0.01" max="255.0" default="2.0" description="Minimum macroblock-level Lagrange multiplier for ratecontrol (default:2.0).&lt;br&gt;This parameter affects adaptive quantization options like qprd, lumi_mask, etc.."/>
            <opt type="float" name="mblmax" min="0.01" max="255.0" default="31.0" description="Maximum macroblock-level Lagrange multiplier for ratecontrol (default: 31.0)."/>
            <opt type="int" name="vqscale"  min="-1" max="31" default="-1" description="Constant quantizer / constant quality encoding (selects fixed quantizer mode). A lower value means better quality but larger files (default: -1).&lt;br&gt;In case of snow codec, value 0 means lossless encoding. Since the other codecs do not support this, vqscale=0 will have an undefined effect. 1 is not recommended (see vqmin for details)."/>
            <opt type="int" name="vqmin" min="1" max="8" default="2" description="minimum quantizer (pass 1/2)&lt;br&gt;-1 : Not recommended (much larger file, little quality difference and weird side effects: msmpeg4, h263 will be very low quality, ratecontrol will be confused resulting in lower quality and some decoders will not be able to decode it).&lt;br&gt;- 2 :Recommended for normal mpeg4/mpeg1video encoding (default).&lt;br&gt;- 3 : Recommended for h263(p)/msmpeg4. The reason for preferring 3 over 2 is that 2 could lead to overflows. (This will be fixed for h263(p) by changing the quantizer per MB in the future, msmpeg4 cannot be fixed as it does not support that.)"/>            
            <opt type="int" name="vqmax"  min="1" max="31" default="31" description="Maximum quantizer (pass 1/2), 10−31 should be a sane range (default: 31)."/>
            <opt type="int" name="vqdiff"  min="1" max="31" default="3" description="maximum quantizer difference between consecutive I- or P-frames (pass 1/2) (default: 3)"/>
            <opt type="int" name="vmax_b_frames" min="0" max="4" default="0" description="maximum number of B-frames between non-B-frames:&lt;br&gt;- 0 : no B-frames (default)&lt;br&gt;- 0−2 : sane range for MPEG-4"/>
            <opt type="int" name="vme" min="0" max="5" default="4" description="motion estimation method. Available methods are:&lt;br&gt;- 0	: none (very low quality)&lt;bt&gt;- 1 : full (slow, currently unmaintained and disabled)&lt;br&gt;- 2 : log (low quality, currently unmaintained and disabled)&lt;br&gt;- 3 : phods (low quality, currently unmaintained and disabled)&lt;br&gt;- 4 : EPZS: size=1 diamond, size can be adjusted with the *dia options (default)&lt;br&gt;- 5 : X1 (experimental, currently aliased to EPZS)&lt;br&gt;- 8 : iter (iterative overlapped block, only used in snow)&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: 0−3 currently ignores the amount of bits spent, so quality may be low."/>
            <opt type="int" name="me_range" min="0" max="9999" default="0" description="motion estimation search range (default: 0 (unlimited))"/>
            <opt type="int" name="mbd" min="0" max="2" default="0" description="Macroblock decision algorithm (high quality mode), encode each macro block in all modes and choose the best. This is slow but results in better quality and file size. When mbd is set to 1 or 2, the value of mbcmp is ignored when comparing macroblocks. If any comparison setting (precmp, subcmp, cmp, or mbcmp) is nonzero, however, a slower but better half-pel motion search will be used, regardless of what mbd is set to. If qpel is set, quarter-pel motion search will be used regardless.&lt;br&gt;-0 : Use comparison function given by mbcmp (default).&lt;br&gt;- 1 : Select the MB mode which needs the fewest bits (=vhq).&lt;br&gt;- 2 : Select the MB mode which has the best rate distortion."/>
            <opt type="bool" name="vhq" default="false" description="Same as mbd=1, kept for compatibility reasons."/>
            <opt type="bool" name="v4mv" default="false" description="Allow 4 motion vectors per macroblock (slightly better quality).&lt;br&gt;Works better if used with mbd>0."/>
            <opt type="bool" name="obmc" default="false" description="overlapped block motion compensation (H.263+)"/>
            <opt type="int" name="inter_threshold" min="-1000" max="1000" default="0"/>
            <opt type="int" name="keyint" min="0" max="300" default="250" description="maximum interval between keyframes in frames (default: 250 or one keyframe every ten seconds in a 25fps movie. This is the recommended default for MPEG-4).&lt;br&gt;Most codecs require regular keyframes in order to limit the accumulation of mismatch error. Keyframes are also needed for seeking, as seeking is only possible to a keyframe - but keyframes need more space than other frames, so larger numbers here mean slightly smaller files but less precise seeking. 0 is equivalent to 1, which makes every frame a keyframe. Values >300 are not recommended as the quality might be bad depending upon decoder, encoder and luck. It is a common for MPEG-1/2 to use values less or =30."/>
            <opt type="int" name="sc_threshold" min="-1000000000" max="1000000000" default="0" description="Threshold for scene change detection. A keyframe is inserted by libavcodec when it detects a scene change.&lt;br&gt;You can specify the sensitivity of the detection with this option. -1000000000 means there is a scene change detected at every frame, 1000000000 means no scene changes are detected (default: 0)."/>
            <opt type="int" name="sc_factor" min="1" max="20" default="1" description="Causes frames with higher quantizers to be more likely to trigger a scene change detection and make libavcodec use an I-frame (default: 1).&lt;br&gt;1−16 is a sane range. Values between 2 and 6 may yield increasing PSNR (up to approximately 0.04 dB) and better placement of I-frames in high-motion scenes. Higher values than 6 may give very slightly better PSNR (approximately 0.01 dB more than sc_factor=6), but noticably worse visual quality."/>
            <opt type="int" name="vb_strategy" min="0" max="2" default="0" description="strategy to choose between I/P/B-frames:&lt;br&gt;- 0 : Always use the maximum number of B-frames (default).&lt;br&gt;- 1 : Avoid B-frames in high motion scenes. See the b_sensitivity option to tune this strategy.&lt;br&gt;- 2 : Places B-frames more or less optimally to yield maximum quality (slower). You may want to reduce the speed impact of this option by tuning the option brd_scale."/>
            <opt type="int" name="b_sensitivity" min="0" max="50" default="40" description="Adjusts how sensitively vb_strategy=1 detects motion and avoids using B-frames (default: 40).&lt;br&gt;Lower sensitivities will result in more B-frames. Using more B-frames usually improves PSNR, but too many B-frames can hurt quality in high-motion scenes. Unless there is an extremely high amount of motion, b_sensitivity can safely be lowered below the default; 10 is a reasonable value in most cases."/>
            <opt type="int" name="brd_scale" min="0" max="10" default="0" description="Downscales frames for dynamic B-frame decision (default: 0). Each time brd_scale is increased by one, the frame dimensions are divided by two, which improves speed by a factor of four. Both dimensions of the fully downscaled frame must be even numbers, so brd_scale=1 requires the original dimensions to be multiples of four, brd_scale=2 requires multiples of eight, etc.&lt;br&gt;In other words, the dimensions of the original frame must both be divisible by 2^(brd_scale+1) with no remainder."/>
            <opt type="int" name="bidir_refine" min="0" max="4" default="0" description="Refine the two motion vectors used in bidirectional macroblocks, rather than re-using vectors from the forward and backward searches. This option has no effect without B-frames.&lt;br&gt;- 0 : Disabled (default).&lt;br&gt;- 1−4	: Use a wider search (larger values are slower)."/>
            <opt type="int" name="vpass" min="1" max="3" default="$PASS" special="$PASS" description="Activates internal two (or more) pass mode, only specify if you wish to use two (or more) pass encoding.&lt;br&gt;- 1 : first pass (also see turbo)&lt;br&gt;- 2 : second pass&lt;br&gt;- 3 : Nth pass (second and subsequent passes of N-pass encoding)&lt;br&gt;&lt;br&gt;Here is how it works, and how to use it:&lt;br&gt;The first pass (vpass=1) writes the statistics file. You might want to deactivate some CPU-hungry options, like 'turbo' mode does.&lt;br&gt;In two pass mode, the second pass (vpass=2) reads the statistics file and bases ratecontrol decisions on it.&lt;br&gt;In N-pass mode, the second pass (vpass=3, that is not a typo) does both: It first reads the statistics, then overwrites them. You might want to backup divx2pass.log before doing this if there is any possibility that you will have to cancel MEncoder. You can use all encoding options, except very CPU-hungry options like 'qns'.&lt;br&gt;You can run this same pass over and over to refine the encode. Each subsequent pass will use the statistics from the previous pass to improve. The final pass can include any CPU-hungry encoding options.&lt;br&gt;If you want a 2 pass encode, use first vpass=1, and then vpass=2.&lt;br&gt;If you want a 3 or more pass encode, use vpass=1 for the first pass and then vpass=3 and then vpass=3 again and again until you are satisfied with the encode."/>
            <opt type="bool" name="turbo" default="true" description="Dramatically speeds up pass one using faster algorithms and disabling CPU-intensive options.&lt;br&gt;This will probably reduce global PSNR a little bit (around 0.01dB) and change individual frame type and PSNR a little bit more (up to 0.03dB)."/>
            <opt type="string" name="aspect" default="" description="Store movie aspect internally, just like with MPEG files. Much nicer than rescaling, because quality is not decreased. Only MPlayer will play these files correctly, other players will display them with wrong aspect. The aspect parameter can be given as a ratio or a floating point number.&lt;br&gt;EXAMPLE: aspect=16/9 or aspect=1.78"/>
            <opt type="bool" name="autoaspect" default="false" description="Same as the aspect option, but automatically computes aspect, taking into account all the adjustments (crop/expand/scale/ etc.) made in the filter chain.&lt;br&gt;Does not incur a performance penalty, so you can safely leave it always on."/>
            <opt type="int" name="vbitrate" min="4" max="16000" default="$VIDBR" special="$VIDBR" description="Specify bitrate (pass 1/2) (default: 800)."/>
            <opt type="int" name="vratetol" min="1000" max="100000" default="8000" description="approximated file size tolerance in kbit. 1000−100000 is a sane range. (warning: 1kbit = 1000 bits) (default: 8000)&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: vratetol should not be too large during the second pass or there might be problems if vrc_(min|max)rate is used."/>
            <opt type="int" name="vrc_maxrate" min="0" max="16000" default="0" description="maximum bitrate in kbit/sec (pass 1/2) (default: 0, unlimited)"/>
            <opt type="int" name="vrc_minrate" min="0" max="16000" default="0" description="minimum bitrate in kbit/sec (pass 1/2) (default: 0, unlimited)"/>
            <opt type="int" name="vrc_buf_size" min="0" max="2000" default="1835" description="buffer size in kbit (pass 1/2).&lt;br&gt;For MPEG-1/2 this also sets the vbv buffer size, use 327 for VCD, 917 for SVCD and 1835 for DVD."/>
            <opt type="int" name="vrc_strategy" min="0" max="1" default="0" description="Ratecontrol method. Note that some of the ratecontrol-affecting options will have no effect if vrc_strategy is not set to 0.&lt;br&gt;- 0 : Use internal lavc ratecontrol (default).&lt;br&gt;- 1 : Use Xvid ratecontrol (experimental; requires MEncoder to be compiled with support for Xvid 1.1 or higher)."/>
            <opt type="float" name="vb_qfactor" min="-31.0" max="31.0" default="1.25" description="quantizer factor between B- and non-B-frames (pass 1/2) (default: 1.25)"/>
            <opt type="float" name="vi_qfactor" min="-31.0" max="31.0" default="0.8" description="quantizer factor between I- and non-I-frames (pass 1/2) (default: 0.8)"/>
            <opt type="float" name="vb_qoffset" min="-31.0" max="31.0" default="1.25" description="quantizer offset between B- and non-B-frames (pass 1/2) (default: 1.25)"/>
            <opt type="float" name="vi_qoffset" min="-31.0" max="31.0" default="0.0" description="(pass 1/2) (default: 0.0)&lt;br&gt;if v{b|i}_qfactor > 0 I/B-frame quantizer = P-frame quantizer * v{b|i}_qfactor + v{b|i}_qoffset&lt;br&gt;else do normal ratecontrol (do not lock to next P-frame quantizer) and set q= -q * v{b|i}_qfactor + v{b|i}_qoffset&lt;br&gt;&lt;u&br;HINT&lt;/u&gt;: To do constant quantizer encoding with different quantizers for I/P- and B-frames you can use: lmin=ip_quant:lmax=ip_quant:vb_qfactor=b_quant/ip_quant."/>
            <opt type="float" name="vqblur" min="0.0" max="99.0" default="0.0" description="Pass One: Quantizer blur (default: 0.5), larger values will average the quantizer more over time (slower change).&lt;br&gt;- 0.0 : Quantizer blur disabled.&lt;br&gt;- 1.0	: Average the quantizer over all previous frames.&lt;br&gt;&lt;br&gt;Pass Two: Quantizer gaussian blur (default: 0.5), larger values will average the quantizer more over time (slower change)."/>
            <opt type="float" name="vqcomp" min="0.0" max="1.0" default="0.5" description="Quantizer compression, vrc_eq depends upon this (pass 1/2) (default: 0.5).&lt;br&gt;For instance, assuming the default rate control equation is used, if vqcomp=1.0, the ratecontrol allocates to each frame the number of bits needed to encode them all at the same QP. If vqcomp=0.0, the ratecontrol allocates the same number of bits to each frame, i.e. strict CBR.&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: Those are extreme settings and should never be used. Perceptual quality will be optimal somewhere in between these two extremes."/>
            <opt type="int" name="vrc_init_cplx" min="0" max="1000" default="0" description="initial complexity (pass 1)"/>
            <opt type="float" name="vrc_init_occupancy" min="0.0" max="1.0" default="0.9" description="initial buffer occupancy, as a fraction of vrc_buf_size (default: 0.9)"/>
            <opt type="int" name="vqsquish" min="0" max="1" default="1" description="Specify how to keep the quantizer between qmin and qmax (pass 1/2).&lt;br&gt;- 0 : Use clipping.&lt;br&gt;- 1 : Use a nice differentiable function (default)."/>
            <opt type="int" name="vlelim" min="-1000" max="1000" default="0" description="Sets single coefficient elimination threshold for luminance. Negative values will also consider the DC coefficient (should be at least -4 or lower for encoding at quant=1):&lt;br&gt;- 0 : disabled (default)&lt;br&gt;- -4 : JVT recommendation"/>
            <opt type="int" name="vcelim" min="-1000" max="1000" default="0" description="Sets single coefficient elimination threshold for chrominance. Negative values will also consider the DC coefficient (should be at least -4 or lower for encoding at quant=1):&lt;br&gt;- 0 : disabled (default)&lt;br&gt;- 7 : JVT recommendation"/>
            <opt type="int" name="vstrict" min="-2" max="1" default="0" description="strict standard compliance&lt;br&gt;- 0 : disabled&lt;br&gt;- 1 : Only recommended if you want to feed the output into the MPEG-4 reference decoder.&lt;br&gt;- -1 : Allow libavcodec specific extensions (default).&lt;br&gt;- -2 : Enables experimental codecs and features which may not be playable with future MPlayer versions (snow)."/>
            <opt type="bool" name="vdpart" default="false" description="Data partitioning. Adds 2 Bytes per video packet, improves error-resistance when transferring over unreliable channels (e.g. streaming over the internet). Each video packet will be encoded in 3 separate partitions:&lt;br&gt;- 1. MVs movement&lt;br&gt;- 2. DC coefficients low res picture&lt;br&gt;- 3. AC coefficients details&lt;br&gt;&lt;br&gt;MV &amp; DC are most important, loosing them looks far worse than loosing the AC and the 1. &amp; 2. partition. (MV &amp; DC) are far smaller than the 3. partition (AC) meaning that errors will hit the AC partition much more often than the MV &amp; DC partitions. Thus, the picture will look better with partitioning than without, as without partitioning an error will trash AC/DC/MV equally."/>
            <opy type="int" name="vpsize" min="0" max="10000" default="0" description="Video packet size, improves error-resistance.&lt;br&gt;- 0 : disabled (default)&lt;br&gt;- 100−1000 : good choice"/>
            <opt type="bool" name="ss" default="false" description="slice structured mode for H.263+"/>
            <opt type="bool" name="gray" default="false" description="grayscale only encoding (faster)"/>
            <opt type="int" name="vfdct" min="0" max="6" default="0" description="DCT algorithm&lt;br&gt;- 0 : Automatically select a good one (default).&lt;br&gt;- 1 :  fast integer&lt;br&gt;- 2 : accurate integer&lt;br&gt;- 3 : MMX&lt;br&gt;- 4 : mlib&lt;br&gt;- 5 : AltiVec&lt;br&gt;- 6 : floating point AAN"/>
            <opt type="int" name="idct" min="0" max="9" default="0" description="IDCT algorithm&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: To the best of our knowledge all these IDCTs do pass the IEEE1180 tests.&lt;br&gt;- 0 : Automatically select a good one (default).&lt;br&gt;- 1 : JPEG reference integer&lt;br&gt;- 2 : simple&lt;br&gt;- 3 : simplemmx&lt;br&gt;- 4 : libmpeg2mmx (inaccurate, do not use for encoding with keyint >100)&lt;br&gt;- 5 : ps2&lt;br&gt;- 6 : mlib&lt;br&gt;- 7 : arm&lt;br&gt;- 8 : AltiVec&lt;br&gt;- 9 : sh4"/>
            <opt type="float" name="lumi_mask" min="0" max="1.0" default="0.0" description="Luminance masking is a ’psychosensory’ setting that is supposed to make use of the fact that the human eye tends to notice fewer details in very bright parts of the picture. Luminance masking compresses bright areas stronger than medium ones, so it will save bits that can be spent again on other frames, raising overall subjective quality, while possibly reducing PSNR.&lt;br&gt;WARNING: Be careful, overly large values can cause disastrous things.&lt;br&gt;WARNING: Large values might look good on some monitors but may look horrible on other monitors.&lt;br&gt;- 0.0 : disabled (default)&lt;br&gt;- 0.0−0.3 : sane range"/>
            <opt type="float" name="dark_mask" min="0" max="1.0" default="0.0" description="Darkness masking is a ’psychosensory’ setting that is supposed to make use of the fact that the human eye tends to notice fewer details in very dark parts of the picture. Darkness masking compresses dark areas stronger than medium ones, so it will save bits that can be spent again on other frames, raising overall subjective quality, while possibly reducing PSNR.&lt;br&gt;WARNING: Be careful, overly large values can cause disastrous things.&lt;br&gt;WARNING: Large values might look good on some monitors but may look horrible on other monitors / TV / TFT.&lt;br&gt;- 0.0 : disabled (default)&lt;br&gt;- 0.0−0.3 : sane range"/>
            <opt type="float" name="tcplx_mask" min="0" max="1.0" default="0.0" description="Temporal complexity masking (default: 0.0 (disabled)). Imagine a scene with a bird flying across the whole scene;&lt;br&gt;tcplx_mask will raise the quantizers of the bird’s macroblocks (thus decreasing their quality), as the human eye usually does not have time to see all the bird’s details. Be warned that if the masked object stops (e.g. the bird lands) it is likely to look horrible for a short period of time, until the encoder figures out that the object is not moving and needs refined blocks. The saved bits will be spent on other parts of the video, which may increase subjective quality, provided that tcplx_mask is carefully chosen."/>
            <opt type="float" name="scplx_mask" min="0" max="1.0" default="0.0" description="Spatial complexity masking. Larger values help against blockiness, if no deblocking filter is used for decoding, which is maybe not a good idea.&lt;br&gt;Imagine a scene with grass (which usually has great spatial complexity), a blue sky and a house; scplx_mask will raise the quantizers of the grass’ macroblocks, thus decreasing its quality, in order to spend more bits on the sky and the house.&lt;br&gt;HINT: Crop any black borders completely as they will reduce the quality of the macroblocks (also applies without scplx_mask).&lt;br&gt;- 0.0 : disabled (default)&lt;br&gt;- 0.0−0.5 : sane range&lt;br&gt;&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: This setting does not have the same effect as using a custom matrix that would compress high frequencies harder, as scplx_mask will reduce the quality of P blocks even if only DC is changing. The result of scplx_mask will probably not look as good."/>
            <opt type="float" name="p_mask" min="0" max="1.0" default="0.0" description="Reduces the quality of inter blocks.&lt;br&gt;This is equivalent to increasing the quality of intra blocks, because the same average bitrate will be distributed by the rate controller to the whole video sequence (default: 0.0 (disabled)). p_mask=1.0 doubles the bits allocated to each intra block."/>
            <opt type="float" name="border_mask" min="0" max="1.0" default="0.0" description="border-processing for MPEG-style encoders.&lt;br&gt;Border processing increases the quantizer for macroblocks which are less than 1/5th of the frame width/height away from the frame border, since they are often visually less important."/>
            <opt type="bool" name="naq" default="false" description="Normalize adaptive quantization (experimental).&lt;br&gt;When using adaptive quantization (*_mask), the average per-MB quantizer may no longer match the requested frame-level quantizer. Naq will attempt to adjust the per-MB quantizers to maintain the proper average."/>
            <opt type="bool" name="ildct" default="false" description="Use interlaced DCT."/>
            <opt type="bool" name="ilme" default="false" description="Use interlaced motion estimation (mutually exclusive with qpel)."/>
            <opt type="bool" name="alt" default="false" description="Use alternative scantable."/>
            <opt type="int" name="top" min="-1" max="1" default="-1" description="- -1 : automatic&lt;br&gt;- 0 : bottom field first&lt;br&gt;- 1 : top field first"/>
            <opt type="string" name="format" default="YV12" description="- YV12 : default&lt;br&gt;- 444P : for ffv1&lt;br&gt;- 422P : for HuffYUV, lossless JPEG, dv and ffv1&lt;br&gt;- 411P : for lossless JPEG, dv and ffv1&lt;br&gt;- YVU9 : for lossless JPEG, ffv1 and svq1&lt;br&gt;- BGR32 : for lossless JPEG and ffv1">
                 <value name="YV12"/>
                 <value name="444P"/>
                 <value name="422P"/>
                 <value name="411P"/>
                 <value name="YVU9"/>
                 <value name="BGR32"/>
            </opt>
            <opt type="string" name="pred" default="0" description="for HuffYUV&lt;br&gt;- 0 : left prediction&lt;br&gt;- 1 : plane/gradient prediction&lt;br&gt;- 2 : median prediction&lt;br&gt;&lt;br&gt;for lossless JPEG&lt;br&gt;- 0 : left prediction&lt;br&gt;- 1 : top prediction&lt;br&gt;- 2 : topleft prediction&lt;br&gt;- 3 : plane/gradient prediction&lt;br&gt;- 6 : mean prediction">
                <value name="0"/>
                <value name="1"/>
                <value name="2"/>
                <value name="3"/>
                <value name="6"/>
            </opt>
            <opt type="int" name="coder" min="0" max="1" default="0" description="for ffv1&lt;br&gt;- 0 : vlc coding (Golomb-Rice).&lt;br&gt;- 1 : arithmetic coding (CABAC)"/>
            <opt type="int" name="context" min="0" max="1" default="0" description="for ffv1&lt;br&gt;- 0 : small context model&lt;br&gt;- 1 : large context model&lt;br&gt;&lt;br&gt;for ffvhuff&lt;br&gt;- 0 : predetermined Huffman tables (builtin or two pass)&lt;br&gt;- 1 : adaptive Huffman tables"/>
            <opt type="bool" name="qpel" default="false" description="Use quarter pel motion compensation (mutually exclusive with ilme).&lt;br&gt;HINT: This seems only useful for high bitrate encodings."/>
            <opt type="int" name="mbcmp" min="0" max="2000" default="0" description="Sets the comparison function for the macroblock decision, has only an effect if mbd=0.&lt;br&gt;-  0 (SAD) : sum of absolute differences, fast (default)&lt;br&gt;-  1 (SSE) : sum of squared errors&lt;br&gt;-  2 (SATD) : sum of absolute Hadamard transformed differences&lt;br&gt;-  3 (DCT) : sum of absolute DCT transformed differences&lt;br&gt;-  4 (PSNR) : sum of squared quantization errors (avoid, low quality)&lt;br&gt;-  5 (BIT) : number of bits needed for the block&lt;br&gt;-  6 (RD) : rate distortion optimal, slow&lt;br&gt;-  7 (ZERO) : 0&lt;br&gt;-  8 (VSAD) : sum of absolute vertical differences&lt;br&gt;-  9 (VSSE) : sum of squared vertical differences&lt;br&gt;-  10 (NSSE) : noise preserving sum of squared differences&lt;br&gt;-  11 (W53) : 5/3 wavelet, only used in snow&lt;br&gt;-  12 (W97) : 9/7 wavelet, only used in snow&lt;br&gt;-  +256 : Also use chroma, currently does not work (correctly) with B-frames."/>
            <opt type="int" name="ildctcmp" min="0" max="2000" default="0" description="Sets the comparison function for interlaced DCT decision&lt;br&gt;(see mbcmp for available comparison functions)."/>
            <opt type="int" name="precmp" min="0" max="2000" default="0" description="Sets the comparison function for motion estimation pre pass&lt;br&gt;(see mbcmp for available comparison functions) (default: 0)."/>
            <opt type="int" name="cmp" min="0" max="2000" default="0" description="Sets the comparison function for full pel motion estimation&lt;br&gt;(see mbcmp for available comparison functions) (default: 0)."/>
            <opt type="int" name="subcmp" min="0" max="2000" default="0" description="Sets the comparison function for sub pel motion estimation&lt;br&gt;(see mbcmp for available comparison functions) (default: 0)."/>
            <opt type="int" name="nssew" min="0" max="1000000" default="8" description="This setting controls NSSE weight, where larger weights will result in more noise.&lt;br&gt;0 NSSE is identical to SSE You may find this useful if you prefer to keep some noise in your encoded video rather than filtering it away before encoding (default: 8)."/>
            <opt type="int" name="predia" min="-99" max="6" default="0" description="diamond type and size for motion estimation pre-pass"/>
            <opt type="int" name="dia" min="-99" max="6" default="0" description="Diamond type &amp; size for motion estimation. Motion search is an iterative process. Using a small diamond does not limit the search to finding only small motion vectors. It is just somewhat more likely to stop before finding the very best motion vector, especially when noise is involved. Bigger diamonds allow a wider search for the best motion vector, thus are slower but result in better quality.&lt;br&gt;Big normal diamonds are better quality than shape-adaptive diamonds.&lt;br&gt;Shape-adaptive diamonds are a good tradeoff between speed and quality.&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: The sizes of the normal diamonds and shape adaptive ones do not have the same meaning.&lt;br&gt;-  -3 : shape adaptive (fast) diamond with size 3&lt;br&gt;-  -2 : shape adaptive (fast) diamond with size 2&lt;br&gt;-  -1 : uneven multi-hexagon search (slow)&mt;br&gt;-  1 : normal size=1 diamond (default) =EPZS type diamond&lt;br&gt;0&lt;br&gt;000&lt;br&gt;0&lt;br&gt;-  2 : normal size=2 diamond&lt;br&gt;0&lt;br&gt;000&lt;br&gt;00000&lt;br&gt;000&lt;br&gt;0"/>
            <opt type="bool" name="trell" default="false" description="Trellis searched quantization. This will find the optimal encoding for each 8x8 block. Trellis searched quantization is quite simply an optimal quantization in the PSNR versus bitrate sense (Assuming that there would be no rounding errors introduced by the IDCT, which is obviously not the case.). It simply finds a block for the minimum of error and lambda*bits.&lt;br&gt;-  lambda : quantization parameter (QP) dependent constant&lt;br&gt;-  bits : amount of bits needed to encode the block&lt;br&gt;-  error : sum of squared errors of the quantization"/>
            <opt type="bool" name="cbp" default="false" description="Rate distorted optimal coded block pattern.&lt;br&gt;Will select the coded block pattern which minimizes distortion + lambda*rate. This can only be used together with trellis quantization."/>
            <opt type="bool" name="mv0" default="false" description="Try to encode each MB with MV=0,0 and choose the better one.&lt;br&gt;This has no effect if mbd=0."/>
            <opt type="int" name="mv0_threshold" min="0" max="1000" default="256" description="When surrounding motion vectors are 0,0 and the motion estimation score of the current block is less than mv0_threshold, 0,0 is used for the motion vector and further motion estimation is skipped (default: 256). Lowering mv0_threshold to 0 can give a slight (0.01dB) PSNR increase and possibly make the encoded video look slightly better; raising mv0_threshold past 320 results in diminished PSNR and visual quality. Higher values speed up encoding very slightly (usually less than 1%, depending on the other options used).&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: This option does not require mv0 to be enabled."/>
            <opt type="bool" name="qprd" default="false" description="rate distorted optimal quantization parameter (QP) for the given lambda of each macroblock"/>
            <opt type="int" name="last_pred" min="0" max="99" default="0" description="amount of motion predictors from the previous frame&lt;br&gt;-  0 : (default)&lt;br&gt;-  a :  Will use 2a+1 x 2a+1 macroblock square of motion vector predictors from the previous frame."/>
            <opt type="int" name="preme" min="0" max="2" default="0" description="motion estimation pre-pass&lt;br&gt;-  0 : disabled&lt;br&gt;-  1 : only after I-frames (default)&lt;br&gt;-  2 : always"/>
            <opt type="int" name="subq" min="1" max="8" default="1" description="subpel refinement quality (for qpel) (default: 8 (high quality))&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: This has a significant effect on speed."/>
            <opt type="bool" name="mpeg_quant" default="false" description="Use MPEG quantizers instead of H.263."/>
            <opt type="bool" name="aic" default="false" description="Enable AC prediction for MPEG-4 or advanced intra prediction for H.263+. This will improve quality very slightly (around 0.02 dB PSNR) and slow down encoding very slightly (about 1%).&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: vqmin should be 8 or larger for H.263+ AIC."/>
            <opt type="bool" name="aiv" default="false" description="alternative inter vlc for H.263+"/>
            <opt type="bool" name="umv" default="false" description="unlimited MVs (H.263+ only) Allows encoding of arbitrarily long MVs."/>
            <opt type="int" name="ibias" min="-256" max="-256"  default="0" description="intra quantizer bias (256 equals 1.0, MPEG style quantizer default: 96, H.263 style quantizer default: 0)&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: The H.263 MMX quantizer cannot handle positive biases (set vfdct=1 or 2), the MPEG MMX quantizer cannot handle negative biases (set vfdct=1 or 2)."/>
            <opt type="int" name="pbias" min="-256" max="-256"  default="0" description="inter quantizer bias (256 equals 1.0, MPEG style quantizer default: 0, H.263 style quantizer default: -64)&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: The H.263 MMX quantizer cannot handle positive biases (set vfdct=1 or 2), the MPEG MMX quantizer cannot handle negative biases (set vfdct=1 or 2).&lt;br&gt;&lt;u&gt;HINT&lt;/u&gt;: A more positive bias (-32 − -16 instead of -64) seems to improve the PSNR."/>
            <opt type="int" name="nr" min="0" max="100000"  default="0" description="Noise reduction, 0 means disabled.&lt;br&gt;0−600 is a useful range for typical content, but you may want to turn it up a bit more for very noisy content (default: 0). Given its small impact on speed, you might want to prefer to use this over filtering noise away with video filters like denoise3d or hqdn3d."/>
            <opt type="int" name="qns" min="0" max="3"  default="0" description="Quantizer noise shaping. Rather than choosing quantization to most closely match the source video in the PSNR sense, it chooses quantization such that noise (usually ringing) will be masked by similar-frequency content in the image. Larger values are slower but may not result in better quality. This can and should be used together with trellis quantization, in which case the trellis quantization (optimal for constant weight) will be used as startpoint for the iterative search.&lt;br&gt;-  0 : disabled (default)&lt;br&gt;-  1 : Only lower the absolute value of coefficients.&lt;br&gt;-  2 : Only change coefficients before the last non-zero coefficient + 1.&lt;br&gt;-  3 : Try all."/>
            <opt type="bool" name="vqmod_amp" default="false" description="experimental quantizer modulation"/>
            <opt type="bool" name="vqmod_freq" default="false" description="experimental quantizer modulation"/>
            <opt type="string" name="dc" default="8" description="intra DC precision in bits (default: 8).&lt;br&gt;If you specify vcodec=mpeg2video this value can be 8, 9, 10 or 11.">
                <value name="8"/>
                <value name="9"/>
                <value name="10"/>
                <value name="11"/>
            </opt>
            <opt type="bool" name="cgop" default="false" description="Close all GOPs. Currently it only works if scene change&lt;br&gt;detection is disabled (sc_threshold=1000000000)."/>
            <opt type="int" name="vglobal" min="0" max="3" default="0" description="Control writing global video headers.&lt;br&gt;-  0 : Codec decides where to write global headers (default).&lt;br&gt;-  1 : Write global headers only in extradata (needed for .mp4/MOV/NUT).&lt;br&gt;-  2 : Write global headers only in front of keyframes.&lt;br&gt;-  3 : Combine 1 and 2."/>
            <opt type="int" name="level" min="0" max="100" default="0" description="Set CodecContext Level. Use 31 or 41 to play video on a Playstation 3."/>
        </lavc>
    </VIDEO>
</OPTIONS>